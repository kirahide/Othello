HTMLファイル

<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.1.9/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.1.9/addons/p5.sound.min.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
    <meta charset="utf-8" />

  </head>
  <body>
    <div id="board"></div>
    <input type="button" value="最初" onclick="unmove_all()">
    <input type="button" value="戻す" onclick="unmove()">
    <input type="button" value="進む" onclick="forward()">
    <input type="button" value="最後" onclick="forward_all()">
    <input type="button" value="新規" onclick="init()">
    <div id="logarea"></div>
    <script src="sketch.js"></script>
  </body>
</html>


CSSファイル

html, body {
  margin: 0;
  padding: 0;
}
canvas {
  display: block;
}
div#board{
  position: relative;
  width: 256px;
  height: 256px;
  background-color: black;
}
div.sq{
  position: absolute;
  width: 28px;
  height: 28px;
  background-color: green;
}
div.sq div.disc {
  position: absolute;
  left: 2px;
  top: 2px;
  width: 24px;
  height: 24px;
  border-radius: 24px;
  background-color: white;
}
div#logarea{
  margin: 8px 0;
  padding: 4px;
  border: 1px solid black;
  white-space: pre;
  width: 248px;
  height: 120px;
  overflow-y: scroll;
}


JSファイル

class GBOARD{
  constructor(parent){
    this.parent = document.getElementById(parent);
    
    // 64マスの情報を保持する配列
    this.sq = new Array(64);
    
    for( let i=0; i<64; i++){
      // １つのマスを表現する div 要素
      let e = document.createElement('div');
      e.className = "sq";

      let x = (i % 8) * 29 + 12;
      let y = Math.floor( i / 8 ) * 29 + 12;
      e.style.left = x + "px";
      e.style.top =  y + "px";

      e.parent = this;
      e.myid = i;
      e.addEventListener( "click", function(){this.parent.OnClick(this.myid);} );
      
      // 石を表現する div 要素
      let d = document.createElement('div');
      d.className = "disc";
      d.style.display = "none";
      e.appendChild( d );
      e.disc = d;
      
      this.parent.appendChild( e );

      this.sq[i] = e;
    }
  }
  // (x,y) のマスに石を置く
  //    d=0 : 石を消す
  //    d=1 : 黒石を置く
  //    d=2 : 白石を置く
  setDisc( x, y, d ){
    let p = y * 8 + x;
    
    // d==0 の場合は非表示に
    this.sq[p].disc.style.display = d == 0 ? "none" : "block";

    if( d > 0 ){
      // 石の色の指定によって背景色を切り替える
      this.sq[p].disc.style.backgroundColor = d == 1 ? "black" : "white";
    }
  }
  
  // Othello bd を渡すことで盤面を表示
  update ( bd ){
    for( let y=0; y<8; y++ ){
      for( let x=0; x<8; x++ ){
        this.setDisc( x, y, bd.get(x,y) );
      }
    }
  }
  
  OnClick ( id ){
//    Log( "click #" + id );
    OnClickBoard( id );
  }
}

// 着手に関する情報を表現するクラス
class MoveInfo {
  constructor(){
    this.turn = 0;  // 手番
    this.pos  = 0;  // 打った場所
    this.flips= 0;  // 裏返した石の数
    this.disc = new Array(20);  // 裏返した石の座標
  }
  clear(){
    this.turn = 0;
    this.pos = 0;
    this.flips = 0;
  }
  addFlipDisc( p ){ this.disc[this.flips++] = p; }
}

const VECT = [ -10, -9, -8, -1, 1, 8, 9, 10 ];

class Othello {
  constructor(){
    this.bd = new Array(91);
    for( let i=0; i<this.bd.length; i++ ){ this.bd[i] = 8; }
    for( let y=0; y<8; y++ ){
      for( let x=0; x<8; x++ ){
        this.bd[this.pos(x,y)] = 0;
      }
    }
    this.bd[this.pos(3,3)] = 2;
    this.bd[this.pos(4,3)] = 1;
    this.bd[this.pos(3,4)] = 1;
    this.bd[this.pos(4,4)] = 2;

    this.moveinfo = new Array(60);
    this.mp = 0;
    this.mpmax = 0;
    
    this.turn = 1;
  }
  pos(x,y) { return (y+1) * 9 + x + 1; }
  pos_x(p) { return p % 9 - 1; }
  pos_y(p) { return Math.floor(p/9)-1; }
  
  // 盤面の初期化
  init (){
    for( let y=0; y<8; y++ ){
      for( let x=0; x<8; x++ ){
        this.bd[this.pos(x,y)] = 0;
      }
    }
    this.bd[this.pos(3,3)] = 2;
    this.bd[this.pos(4,3)] = 1;
    this.bd[this.pos(3,4)] = 1;
    this.bd[this.pos(4,4)] = 2;

    this.mp = 0;
    this.mpmax = 0;
    
    this.turn = 1;
  }
  
  // (x,y) のマスの状態を取得
  get( x, y ) {
    return this.bd[this.pos(x,y)];
  }
  
  // (x,y) のマスに打つ
  move ( x, y ){
    let p = this.pos( x, y );
    if( this.bd[p] != 0 ){     // 空きマスでなければ、
      return 0;                // ここには打てない
    }
    let moveinfo = new MoveInfo();
    let flipdiscs = 0;
    let oppdisc = this.turn == 2 ? 1 : 2;
    for( let v=0; v<VECT.length; v++ ){  // 8方向全てについて；
      let vect = VECT[v];
      
      let n=p+vect;      // vect方向の隣のマス
      let flip = 0;
      while(this.bd[n] == oppdisc){  // 連続する相手の石を
        n+=vect;
        flip++;                      // カウントする
      }
      
      // 1個以上相手の石が連続しており、その先に自分の石がある場合、
      if( flip > 0 && this.bd[n] == this.turn ){
        for( let i=0; i<flip; i++){  // その相手の石を自分の石にする
          this.bd[n-=vect] = this.turn;
          
          moveinfo.addFlipDisc( n );
        }
        flipdiscs += flip;           // 返した石の数を足し込む
      }
    }
    if( flipdiscs > 0 ){        // 打てた場合
      this.bd[p] = this.turn;   // 打ったマスを自分の石にする
      
      moveinfo.pos = p;
      moveinfo.turn = this.turn;
      this.moveinfo[this.mp++] = moveinfo;
      this.mpmax = this.mp;
      
      this.setNextTurn();       // 手番を変える
    }
    return flipdiscs;  
  }
  // 手番を変える
  setNextTurn (){
    // 要修正：パスの判定が必要
    this.turn = this.turn == 2 ? 1 : 2;
    if( this.isPass( this.turn ) ){
      this.turn = this.turn == 2 ? 1 : 2;
      if( this.isPass( this.turn ) ){
        this.turn = 0;
      }
    }
  }
  // turn 番でパスになるか調べる
  isPass ( turn ){
    for( let y=0; y<8; y++ ){
      for( let x=0; x<8; x++ ){
        if( this.canMove(x,y,turn)){
          return false;
        }
      }
    }
    return true;
  }
  // (x,y) に turn 番で打てるか調べる
  canMove ( x, y, turn ){
    let p = this.pos( x, y );
    if( this.bd[p] != 0 ){     // 空きマスでなければ、
      return false;            // ここには打てない
    }
    let flipdiscs = 0;
    let oppdisc = turn == 2 ? 1 : 2;
    for( let v=0; v<VECT.length; v++ ){  // 8方向全てについて；
      let vect = VECT[v];
      
      let n=p+vect;      // vect方向の隣のマス
      let flip = 0;
      while(this.bd[n] == oppdisc){  // 連続する相手の石を
        n+=vect;
        flip++;                      // カウントする
      }
      
      // 1個以上相手の石が連続しており、その先に自分の石がある場合、
      if( flip > 0 && this.bd[n] == turn ){
        return true;
      }
    }
    return false;  
  }
  // １手戻す
  unmove (){
    if( this.mp <= 0 ){
      return false;
    }
    let moveinfo = this.moveinfo[--this.mp];
    
    let opp = moveinfo.turn == 1 ? 2 : 1;
    
    for( let i=0; i<moveinfo.flips; i++ ){
      this.bd[moveinfo.disc[i]] = opp;
    }
    this.bd[moveinfo.pos] = 0;
    
    this.turn = moveinfo.turn;
    
    return true;
  }
  // １手進める
  forward (){
    if( this.mp >= this.mpmax ){
      return false;
    }
    let moveinfo = this.moveinfo[this.mp++];
    let opp = moveinfo.turn == 1 ? 2 : 1;
    
    for( let i=0; i<moveinfo.flips; i++ ){
      this.bd[moveinfo.disc[i]] = moveinfo.turn;
    }
    this.bd[moveinfo.pos] = moveinfo.turn;
    
    this.turn = moveinfo.turn;
    this.setNextTurn();
    
    return true;
  }
  unmove_all(){
    if( !this.unmove() ){
      return false;
    }
    while( this.unmove() ){
      ;
    }
    return true;
  }
  forward_all(){
    if( !this.forward() ){
      return false;
    }
    while( this.forward() ){
      ;
    }
    return true;
  }
}
let gBoard = null;
let gOthello = null;

// 盤面の初期化 (新規ゲームスタート)
function init (){
  gOthello.init();
  gBoard.update( gOthello );
}
// １手戻す
function unmove (){
  if( gOthello.unmove() ){
    gBoard.update( gOthello );
  }
}
// １手進める
function forward (){
  if( gOthello.forward() ){
    gBoard.update( gOthello );
  }
}
function unmove_all (){
  if( gOthello.unmove_all() ){
    gBoard.update( gOthello );
  }
}
function forward_all (){
  if( gOthello.forward_all() ){
    gBoard.update( gOthello );
  }
}
// 盤上でクリックされた時の処理
function OnClickBoard ( pos ){
  let x = pos % 8;
  let y = Math.floor( pos / 8 );
  // (x,y)に打つ
  if( gOthello.move( x, y ) > 0 ){
    gBoard.update( gOthello );
  }
}

function setup() {
  noLoop();    // draw() 関数の定期的な呼び出しを行わない

  // index.html の id="board" な div の中にオセロ盤を作成
  gBoard = new GBOARD( "board" );

  gOthello = new Othello();
  gBoard.update( gOthello );
  
}

// この関数は使わない
function draw() {
}

// ログ表示領域に文字列 s を表示
function Log ( s ){
  let e = document.getElementById( "logarea" );
  if( e ){
    e.innerHTML += s + "\n";
    e.scrollTop = e.scrollHeight
  }
}
